\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\title{Exploring Bacon's Law; Actors and their Associates Connected through Film}
\author{Tai Poole, Nabhan Rashid, Danny Tran}
\date{March 5, 2025}

\begin{document}

\maketitle

\section{Problem Description}
There is a well known pop culture game known as the ``Bacon Number Game." The Bacon Number Game revolves around the conjecture of Bacon’s Law that every actor in Hollywood is connected to Kevin Bacon through 6 degrees of separation or less (1). The game is then to find this path. If we consider each actor a vertex in a graph, two actors are related when they have acted in the same movie, which we define as an edge. The degree of separation is defined as the smallest path length between two actors. Note that similar to the definition of a path for graphs, Kevin Bacon is the only person with a Kevin Bacon number of 0. One might also know this system by the similar game in math, the Erdős number, or the similar popular game The Wiki game (2). \\\\
It’s an amusing thought experiment, suggesting that Hollywood isn’t that big and most of our movies are just the same few actors over and over again or that at some point, every actor in Hollywood has worked with each other. As our group was discussing it, we also reflected on why the focus was Kevin Bacon, an actor we did not feel was very popular anymore. This was because the Bacon number was conceived in 1994, back when Kevin Bacon was a much larger presence in pop culture. Because of this, we wanted to broaden the Bacon number's concept to the degrees of separation of \emph{any} two actors, to make it more generalizable and timeless. \textbf{In this project, we seek to understand the level of interconnectivity between professionals in the movie industry, and to examine the legitimacy of the famous Bacon’s Law. In doing so we also hope to modernize the Bacon's Law, and show it holds even when only considering recent movies, and alive actors.}

\section{The Datasets}
For our domain, we are going to use the IMDb movie datasets (3). To make our connections we will use the [title.principals.tsv.gz] database; which contains every role in the various IMDb movies along with associated Actor IDs, Movie IDs and their role names. Additionally, we are using two additional databases to match Movie IDs with Movie Names and Actor IDs and Actor names [name.basics.tsv.gz] and [title.basics.tsv.gz]. These databases are also compiled to give restrictions on the path we find, using attributes such as their deathYear to filter out dead actors. Below is an example of the [title.principals.tsv.gz] dataset.
\begin{verbatim}
    tconst    ordering    nconst    category    job    characters
tt0000001    1    nm1588970    self    \N    ["Self"]
tt0000002    1    nm0721526    director    \N    \N
tt0000005    1    nm0443482    actor    \N    ["Blacksmith"]
\end{verbatim}
The data from the three datasets are TSV files with string IDs identifying actors and movies. Actors are identified with alphanumeric strings beginning with ``nm” (such as nm0000001 for ``Fred Astaire”) and movies are identified with similar strings beginning with ``tt” (such as tt0133093 for ``The Matrix”). 

\section{Computational Overview}
The graph itself will be represented as an SQL database. To be more specific, an \verb+sqlite+ database. This was for various reasons, but chief among them was size constraints. We tried an entirely NetworkX graph at the start of the project, but we quickly realized the 12GB of RAM it required was infeasible. On the other hand, the SQL database requires 0.5GB of \emph{hard drive} space and keeps a fast processing speed. To create this database, we have the file \verb+sql_processing.py+ which is split into two parts. Then the graph processing. Once the graph is initialized our program is designed to traverse the graph using breadth-first search in \verb+graph_processing+. This file is built to find the shortest path between two actors (And also find the shortest path between two actors given a variety of restrictions) and to create a \verb+NetworkX+ graph to be passed for display. Finally, to make the data more palatable, the file \verb+gui_interface.py+ is where we use \verb+tkinter+, \verb+matplotlib+, and \verb+NetworkX+ in tandem to free the user from staring at text-based information and typing their commands.

\subsection{SQL Database Creation}

The first step in initializing the SQL graph database is compiling the TSV files into an easy-to-access structure. This is the duty of \verb!compile_full_data! which assumes the existence and location of the three TSV files, and uses them to fill the SQL database with the same information, but with random access. The files are read using the \verb!csv! module, changing the delimiter to a tab (\verb!\t!) instead of a comma. Any sqlite database call and insertion is done with the \verb!sql.Connection!, \verb!sql.Connection.commit()!, \verb!sql.Cursor!, and \verb!sql.Cursor.execute! classes and methods.

This database is then used to compile a graph of actors and movies, with edges where an actor has played a part in a movie. It is in this step of the process where the filtering happens. Within the IMDb database there are many \emph{media} and \emph{people}, but not all of them are movies and actors. There are many TV episodes, directors, camera people, e.t.c. This is why the data is filtered using attributes of the previously created database such as \verb+category+ (see above example of [title.principals.tsv.gz]), and primaryProfession. We also ensure the nodes have helpful attributes, such as startYear for movies and deathYear for actors, which will be used in later processing. It is with this use SQL shows its strength, allowing fast and elegant filtering of data for our use. 

The SQL graph database is made of three tables, one for movies, one for actors, and one for edges. The former two have the above stated attributes, and are indexed by their respective IDs for fast lookup times. The latter is an \verb+adjacency_list+, chosen due to the high amount of queries to what nodes are connected to a specific node (Rather than querying whether two nodes are connected, for which an \verb+adjacency_matrix+ is useful). The edges are between two IDs, and so every row of the table has information on which nodes are connected to a central node. Because the edges are between IDs, this allows for a handy optimization, as the IDs are guaranteed to be unique, indexing them means extremely fast lookup times for the adjacent nodes. It is for this reason the SQL graph representation is so fast, and why it was our best choice for data structure.

\subsection{The Graph Processing}

Now that the graph is created, we want to find the shortest path between two actors. There are various helper functions assisting the pathfinding, but there are two functions actually doing the work, \verb+get_path+ and \verb+get_restricted_path+ for a normal, and restricted path respectively. The algorithm in use is a Breadth First Search, and makes use of the \verb+deque+ data structure provided by Python. During the restricted path search, we take in the restrictions we desire, and before adding it to the queue, it's attributes in the database are checked against the requirements using an SQL query.

We felt it would be best to \emph{show} the user what their path looks like, instead of just listing the movies and actors. This is why once a path is found, the \verb!make_networkx_graph! method takes the path, and returns a colour-coded graph. Green for the end-points, salmon for the movies, and bisque for the people. This is done with the \verb+networkx.Graph+ class. Though we couldn't use it for the large database, its \verb!draw! methods made it invaluable in representing graphs, and the memory problem it created didn't exist on such a small scale.  

\subsection{The User Interface}

From this dataset we will create individual nodes using the actor dataset, with actor IDs and actor names as attributes, then connect them with edges using the “principals” dataset with edges that have the attributes of the connecting movies (movie name and ID) to create a graph to represent our actor connectedness. Our vertices of this graph will be actors, with edges between actors being the existence of a movie they were both in. To find the connections and distances between actors, we will use pathfinding algorithms on our graphs, for which there have been many well documented examples we can pull on. Since we have an undirected, unweighted graph, we can just use BFS ("Breadth First Search"). However, we are also considering introducing weights to our edges if we can find a reasonable weighting scheme, and this might require more complex path-finding algorithm like Djikstra’s ("Find Shortest Paths using Dijkstra's Algorithm”) or A* ("A* search algorithm"). \\\\
We will be building the data type from the ground up, and we will need to read the data, which is stored as a TSV, and process it into nodes and edges. This processing will require usage of the csv module’s TSV capabilities ("CSV File Reading and Writing"). To do this we will be processing three data sets from the given data set. Due to how it is set up, there will be three main data variables; two dictionaries will relate the id to the name, one for the movies and one for the people, and a graph will relate people ids, with edges representing movies both people have acted in.\\\\
The graph specifically will be the data structure created by NetworkX. This is specifically for the fact that it allows for attributes on the nodes and edges, and has support for multigraphs, as two actors may have acted in multiple movies together, and in fact may act in multiple movies together on purpose. The edges will have an attribute for the movie’s id, and the nodes will have the id of the actor. By doing this, we can easily output the graph for found path’s nodes, as we can use the subgraph method for graphs in NetworkX to receive a graph that can be printed with all the necessary information. NetworkX will be what creates the graph itself, as after getting the subgraph, NetworkX can draw the graph with matplotlib ("Drawing Documentation"). The induced subgraph will include random connected nodes for aesthetics, and in the cases where two actors have played in many movies together, the induced subgraph will only include some of those edges. \\\\
To process the user input, we will use the GUI library tkinter. Tkinter functions by creating a Tk class which serves as a window container for miscellaneous “widgets”. These widgets will be our interactable elements such as text input fields and buttons to allow the user to more easily interact with the program than just a CLI ("tkinter"). Once the user inputs their query and it is processed by the program, we will display the result using NetworkX. What will happen is we will make a call to the NetworkX draw method to draw the graph itself, before making a call to the NetworkX draw\_networkx\_edge\_labels method and finally making a call to the matplotlib method draw which will open the graph in a new window ("Matplotlib 3.1.2 documentation").

\section{Bibliography}

(1) “Six Degrees of Kevin Bacon.” Wikipedia, https://en.wikipedia.org/wiki/Six\_Degrees\_of\_Kevin\_Bacon. Accessed 1 March 2025.\\\\

(2) “Wikipedia:Wiki Game.” Wikipedia, https://en.wikipedia.org/wiki/Wikipedia:Wiki\_Game. Accessed 1 March 2025.\\\\

Belwariar, Rachit. “A* Search Algorithm.” GeeksforGeeks, 30 July 2024, https://www.geeksforgeeks.org/a-search-algorithm/. Accessed 4 March 2025.\\\\

(2) Chayes, Lincoln, et al. “Erdős number.” Wikipedia, https://en.wikipedia.org/wiki/Erd\%C5\%91s\_number. Accessed 1 March 2025.\\\\

(3) IMDB. “IMDb Data Files.” IMDb Data Files Download, 2024, https://datasets.imdbws.com/. Accessed 1 March 2025.\\\\

“csv — CSV File Reading and Writing — Python 3.13.2 documentation.” Python Docs, https://docs.python.org/3/library/csv.html. Accessed 5 March 2025.\\\\


“Documentation for Show.” matplotlib.pyplot.show - "Matplotlib 3.1.2 documentation." Accessed March 2, 2025. https://matplotlib.org/3.1.1/api/\_as\_gen/matplotlib.pyplot.show.html.\\\\

“Drawing Documentation.” Drawing - NetworkX 3.4.2 documentation. Accessed March 2, 2025. https://networkx.org/documentation/stable/reference/drawing.html.\\\\

Jain, Sandeep. “Breadth First Search or BFS for a Graph.” GeeksforGeeks, 26 February 2025, https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/. Accessed 2 March 2025.\\\\

Jain, Sandeep. “Find Shortest Paths from Source to all Vertices using Dijkstra's Algorithm.” GeeksforGeeks, 26 February 2025, https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/. Accessed 2 March 2025.\\\\

“tkinter — Python interface to Tcl/Tk — Python 3.13.2 documentation.” Python Docs, https://docs.python.org/3/library/tkinter.html\#module-tkinter. Accessed 3 March 2025.\\\\




IMDb has asked that we source their dataset as such:\\
Information courtesy of
IMDb
(https://www.imdb.com).
Used with permission.

\end{document}
